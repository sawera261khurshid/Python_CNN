# -*- coding: utf-8 -*-
"""conv_fp16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G7IU0ugDy4AMxYAo6OJyGgbYhl1KPTLE
"""

import numpy as np
class Conv3x3_1_to_n_padding:
  # A Convolution layer using 3x3 filters.

  def __init__(self, output=1, input=1):
    num_filters = np.float16(output)
    in_ch = np.float16(input)

    self.num_filters = num_filters

    # filters is a 3d array with dimensions (num_filters, 3, 3)
    # We divide by 9 to reduce the variance of our initial values
    self.filters = np.random.randn(num_filters, 3, 3).astype(np.float16) / 9
    np.save('conv_filters_3d',self.filters)

  def iterate_regions(self, image):
    '''
    Generates all possible 3x3 image regions using valid padding.
    - image is a 2d numpy array.
    '''
    image_padded = np.pad(image,1,mode="constant", constant_values=0)
    h, w = image_padded.shape[:2]
    for i in range(h - 2):
      for j in range(w - 2):
          im_region = image_padded[i:(i + 3), j:(j + 3)]
          yield im_region, i, j

  def forward(self, input):
    '''
    Performs a forward pass of the conv layer using the given input.
    Returns a 3d numpy array with dimensions (h, w, num_filters).
    - input is a 2d numpy array
    '''
    self.last_input = input.astype(np.float16)

    h, w = input.shape
    output = np.zeros((h, w , self.num_filters), dtype = np.float16)
    # output = np.zeros((h - 2, w - 2, self.num_filters))

    for im_region, i, j in self.iterate_regions(input):
      output[i, j] = np.sum(im_region * self.filters, axis=(1, 2), dtype = np.float16)

    self.last_output = output
    return output

  def backprop(self, d_L_d_out, learn_rate):
    '''
    Performs a backward pass of the conv layer.
    - d_L_d_out is the loss gradient for this layer's outputs.
    - learn_rate is a float.
    '''
    d_L_d_filters = np.zeros(self.filters.shape, dtype=np.float16)
    d_L_d_input   = np.zeros(self.last_input.shape, dtype=np.float16)

    for im_region, i, j in self.iterate_regions(self.last_input):
      for f in range(self.num_filters):
        d_L_d_filters[f] += d_L_d_out[i, j, f] * im_region

    for out_ch in range(self.num_filters):
      d_L_d_input[:,:] += d_L_d_out[:,:, out_ch] * self.last_input[:,:]


    # errors of previous layer = weights_of_this_layer-T * errors of this layer

    # Update filters
    self.filters -= learn_rate * d_L_d_filters

    return d_L_d_input




class Conv3x3_n_to_n_padding:
  # A Convolution layer using 3x3 filters.

  def __init__(self, output=1, input=1):
    num_filters = np.float16(output)
    in_ch = np.float16(input)

    self.num_filters = num_filters

    # filters is a 3d array with dimensions (num_filters, 3, 3)
    # We divide by 9 to reduce the variance of our initial values
    self.filters = np.random.randn(num_filters, 3, 3, in_ch).astype(np.float16) / 9
    np.save('conv_filters_3d',self.filters)

  def iterate_regions(self, image):
    '''
    Generates all possible 3x3 image regions using valid padding.
    - image is a 2d numpy array.
    '''
    image_padded = np.pad(image,1,mode="constant", constant_values=0)[:,:,1:-1]
    h, w = image_padded.shape[:2]
    for i in range(h - 2):
      for j in range(w - 2):
          im_region = image_padded[i:(i + 3), j:(j + 3), :]
          yield im_region, i, j

  def forward(self, input):
    '''
    Performs a forward pass of the conv layer using the given input.
    Returns a 3d numpy array with dimensions (h, w, num_filters).
    - input is a 2d numpy array
    '''
    self.last_input = input.astype(np.float16)

    h, w, c = input.shape
    output = np.zeros((h, w , self.num_filters), dtype = np.float16)
    # output = np.zeros((h - 2, w - 2, self.num_filters))

    for im_region, i, j in self.iterate_regions(input):
      for filter in range(self.num_filters):
        output[i, j, filter] = np.sum(im_region * self.filters[filter,:,:,:], axis=(0, 1, 2), dtype = np.float16)


    self.last_output = output
    return output.astype(np.float16)

  def backprop(self, d_L_d_out, learn_rate):
    '''
    Performs a backward pass of the conv layer.
    - d_L_d_out is the loss gradient for this layer's outputs.
    - learn_rate is a float.
    '''
    d_L_d_filters = np.zeros(self.filters.shape, dtype=np.float16)

    for im_region, i, j in self.iterate_regions(self.last_input):
      for f in range(self.num_filters):
        d_L_d_filters[f] += d_L_d_out[i, j, f] * im_region



    d_L_d_input   = np.zeros(self.last_input.shape, dtype=np.float16)

    # Method 4
    for im_region, i, j in self.iterate_regions(d_L_d_out):
      for in_ch in range(d_L_d_input.shape[-1]):
        # d_L_d_input[i,j,in_ch] += np.sum ( im_region[:,:,:] * np.transpose( self.filters[:,:,:,in_ch]) , axis=(0,1,2) )
        d_L_d_input[i,j,in_ch] += np.sum( np.matmul( im_region[:,:,:] , np.transpose( self.filters[:,:,:,in_ch] , axes=(2,0,1)) ) , axis=(0,1,2) )


    # Update filters
    self.filters -= learn_rate * d_L_d_filters

    return d_L_d_input.astype(np.float16)
