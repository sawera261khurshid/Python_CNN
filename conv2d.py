# -*- coding: utf-8 -*-
"""conv2d.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uASg4iNs8jC8k0M8vump3TzPBFVu4gVR
"""

import numpy as np

class Conv2D:
    def __init__(self, in_channels, out_channels, kernel_size, stride=1, padding=0):
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.W = np.random.randn(out_channels, in_channels, kernel_size, kernel_size)
        self.b = np.zeros((out_channels, 1))
        
    def forward(self, X):
        N, C, H, W = X.shape
        F, C, HH, WW = self.W.shape
        
        # Compute output spatial size
        out_h = int((H + 2 * self.padding - HH) / self.stride + 1)
        out_w = int((W + 2 * self.padding - WW) / self.stride + 1)
        
        # Pad input
        X_padded = np.pad(X, ((0, 0), (0, 0), (self.padding, self.padding), (self.padding, self.padding)), mode='constant')
        
        # Initialize output tensor
        out = np.zeros((N, F, out_h, out_w))
        
        # Perform convolution
        for n in range(N):
            for f in range(F):
                for i in range(out_h):
                    for j in range(out_w):
                        out[n, f, i, j] = np.sum(X_padded[n, :, i*self.stride:i*self.stride+HH, j*self.stride:j*self.stride+WW] * self.W[f]) + self.b[f]
        
        return out